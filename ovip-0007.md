```pseudocode
OVIP: 7
Title: Message Layer Interface & Session Model
Author: David Riegelnig <david.riegelnig@bitcoinsuisse.com>
Discussions-To:
Status: Proposal
Type: Standard
Created: 2020-05-25
```

# Abstract

Text

# Specification

## 1. Three-layer Model

The OpenVASP protocol defines three layers to establish a structured communication between VASPs.

**Message Layer**</br>
Functionality to send and receive asynchronous messages including routing, reliability and encryption. The protocol defines an interface description for messages as well an implementation for Ethereum Whisper.

**Session Layer**</br>
Functionality to open, control and end the dialog between two VASPs, which is called a session.

**Application Layer**</br>
Specific interaction flow between two VASPs in a session, e.g. agreeing on a virtual asset transfer and transmission of travel rule information according to FATF requirements.

## 2. Message Layer (Interface Description)

### 2.1. Definitions

**Message**</br>
Message conformant to the OpenVASP interface description given below.

**Sender**</br>
VASP sending a *Message*.

**Receiver**</br>
VASP receiving a *Message*.

### 2.2. Message Structure

*Messages* are JSON files as specified in RFC 8259 and must contain the following elements:

| Level 1   | Level 2 | Name      | Type   | Description                                    |
| --------- | ------- | --------- | ------ | ---------------------------------------------- |
| Content   |         | `content` | Object |                                                |
|           | Header  | `header`  | Object | See 2.2.1.1                                    |
|           | Body    | `body`    | Object | Defined on Session Layer and Application Layer |
| Signature |         | `sig`     | String | See 2.2.1.2                                    |

#### 2.2.1 Header

`header` is a JSON object and must contain the following elements:

| Level 3            | Name       | Type         | Description                                    |
| ------------------ | ---------- | ------------ | ---------------------------------------------- |
| Version            | `version`  | String       | Fixed value: `1.0`                             |
| Sender             | `sender`   | Hex(32-bit)  | VASP Code of the *Sender*                      |
| Receiver           | `receiver` | Hex(32-bit)  | VASP Code of the *Receiver*                    |
| Message identifier | `msgid`    | Hex(128-bit) | Randomly set                                   |
| Session identifier | `session`  | Hex(128-bit) | Defined on Session Layer                       |
| Message type       | `type`     | String       | Defined on Session Layer and Application Layer |

#### 2.2.2. Signature

The value assigned to `sig` is the cryptographic signature of the `content` object generated by the *Sender*. Signature must be verifiable with the public `signingKey` available from the *Sender's* VASP Contract, which is retrieved from the Index Contract using the *Sender's* VASP Code (value assigned to `sender`).

### 2.3. Message Encryption

*Messages* must be encrypted for transmission, either at the message level or at the transport level.

Encryption can be asymmetric or symmetric using a shared secret established over an insecure channel (Diffieâ€“Hellman key exchange). In both cases the public `handshakeKey` should be used, which is available from the *Receiver's* VASP Contract, which is retrieved from the Index Contract using the *Receiver's* VASP Code (value assigned to `receiver`).

### 2.4. Message Routing

*Messages* should be routed to the *Receiver* based on his VASP Code.

### 2.5. Message Reliability

Implementations should ensure that feedback is provided to the *Sender* whether the *Message* was successfully delivered to the *Receiver*.

## 3. Session Layer

### 3.1. Definitions

**Session**</br>
Bidirectional exchange of functionally linked *Messages* between two VASPs.

**Session Messages**</br>
*Messages* of specified types used to initiate, accept, decline, close and abort a *Session*.

**Initiator**</br>
VASP initiating a *Session*.

**Responder**</br>
VASP responding to a *Session* initiation.

**Exception**</br>
Error or unexpected event ocurring to one of the parties during a *Session*, e.g. receiving an incorrect *Message* or the absence of a response.

**Exception Handling**</br>
Process of observing and responding to an *Exception*.

### 3.2. Session Flow

#### 3.2.1. Session States

A *Session* can exist in several states as listed in the table below. Given the asynchronous nature of exchanged *Messages*, the *Session* states of the *Initiator* and the *Responder* will temporarily differ until state-changing *Messages* are received. In case of an *Exception*, *Sessions* can end in different states for the two VASPs.

| State       | Description                                                  | Applicable to        |
| ----------- | ------------------------------------------------------------ | -------------------- |
| `initiated` | Responder has been asked to join the session; no response yet | Initiator            |
| `invited`   | Request to join a session has been received; answer is pending | Responder            |
| `declined`  | Session declined by the Responder                            | Initiator, Responder |
| `open`      | Session was accepted by the Responder and is active          | Initiator, Responder |
| `closed`    | Session was orderly closed by the Initiator                  | Initiator, Responder |
| `aborted`   | Session was aborted by either of the VASPs due to an exception | Initiator, Responder |

#### 3.2.2. Initiating a Session

The *Session* is initiated by a *Message* of type `Session Request` (see 3.3.1 for details).

| Start | Message Type    | Activity    | Actor     | State before | State after | Outcome |
| :---: | --------------- | :---------- | --------- | :----------- | :---------- | :-----: |
|   1   | Session Request | sent by     | Initiator | (none)       | `initiated` |    2    |
|   2   | Session Request | received by | Responder | (none)       | `invited`   |    3    |

#### 3.2.3. Responding to a Session Initiation

A *Message* of type `Session Reply` is sent to respond to a *Session* initiation (see 3.3.2 for details).

| Start | Message Type  | Activity    | Actor     | State before | State after | Outcome |
| :---: | ------------- | :---------- | --------- | :----------- | :---------- | :-----: |
|   3   | Session Reply | sent by     | Responder | `invited`    | `declined`  |   4a    |
|   3   | Session Reply | sent by     | Responder | `invited`    | `open`      |   4b    |
|  4a   | Session Reply | received by | Initiator | `initiated`  | `declined`  |    5    |
|  4b   | Session Reply | received by | Initiator | `initiated`  | `open`      |    6    |

The choice whether to decline or accept entering into the *Session* initiated by the *Initiator* is encoded in the response.

If declined, the interaction ends with a *Session* in state `declined` for both the *Initiator* and the *Responder* once the *Message* is received (outcome 5). If accepted, the *Session* is in state `open` for both VASPs once the *Message* is received (outcome 6).

A *Session* in state `open` is required for the exchange of application-related *Messages* (see 4. Application Layer).

#### 3.2.4. Ending a Session

The *Session* is ended by a *Message* of type `Termination` (see 3.3.3 for details), which is always sent by the *Initiator*.

| Start | Message Type | Activity    | Actor     | State before | State after | Outcome |
| :---: | ------------ | :---------- | --------- | :----------- | :---------- | :-----: |
|   6   | Termination  | sent by     | Initiator | `open`       | `closed`    |    7    |
|   7   | Termination  | received by | Responder | `open`       | `closed`    |    8    |

#### 3.2.5. Aborting a Session

Aborting a *Session* is done by sending a `Session Abort` *Message* (see 3.3.4 for details).

Sessions in state `open` can be aborted by either of the VASPs at any time to react to *Exceptions* or out of operational necessity. In addition, the *Initiator* can abort a *Session* in state `initiated`.

There is no need aborting a *Session* in state `invited` as the *Responder* can send a decline `Session Reply` *Message* instead. It further makes no sense aborting a session being in one of the states `declined`, `closed` or `aborted` already.

The next two sections list all possible combinations that can occur when a *Session* is aborted by either the *Initiator* or the *Responder*.

##### 3.2.5.1. Initiator Aborts a Session

| Start | Message Type  | Activity    | Actor     | State before | State after | Outcome |
| :---: | ------------- | :---------- | --------- | :----------- | :---------- | :-----: |
|   2   | Session Abort | sent by     | Initiator | `initiated`  | `aborted`   |  9-13   |
|   6   | Session Abort | sent by     | Initiator | `open`       | `aborted`   | 12, 13  |
|   9   | Session Abort | received by | Responder | (none)       | `aborted`   |   14    |
|  10   | Session Abort | received by | Responder | `invited`    | `aborted`   |   14    |
|  11   | Session Abort | received by | Responder | `declined`   | `declined`  |   14    |
|  12   | Session Abort | received by | Responder | `open`       | `aborted`   |   14    |
|  13   | Session Abort | received by | Responder | `aborted`    | `aborted`   |   14    |

When receiving a `Session Abort` *Message* from the *Initiator*, the *Responder's Session* can be in one of the states listed in starting situations 9-13.

Some of these situations are actually "race conditions" that can occur due to asynchronous communication and the possibility of delayed or failed delivery of a previous *Message*. For instance, situation 9 depicts a case where the *Responder* receives the `Session Abort` *Message* before even knowing about the *Session*. Situation 13 occurs if both VASPs have concurrently aborted the Session.

The receipt of a `Session Abort` *Message* changes the *Session's* state to `aborted` in all but one situation. The only exception is a *Session* in state `declined`, which keeps its state. This rule ensures that the *Responder's* decision to decline before learning about the *Initiator's* attempt to abort the *Session* is put on record.

##### 3.2.5.2. Responder Aborts a Session

| Start | Message Type  | Activity    | Actor     | State before | State after | Outcome |
| :---: | ------------- | :---------- | --------- | :----------- | :---------- | :-----: |
|  4b   | Session Abort | sent by     | Responder | `open`       | `aborted`   |  15-18  |
|  15   | Session Abort | received by | Initiator | `initiated`  | `aborted`   |   19    |
|  16   | Session Abort | received by | Initiator | `open`       | `aborted`   |   19    |
|  17   | Session Abort | received by | Initiator | `closed`     | `closed`    |   19    |
|  18   | Session Abort | received by | Initiator | `aborted`    | `aborted`   |   19    |

When receiving a `Session Abort` *Message* from the *Responder*, the *Initiator's Session* can be in one of the states listed in starting situations 15-18. After the receipt, the state is changed to `aborted` in all cases with exception of situation 16, where a *Session* in state `closed` keeps its state.

### 3.3. Session Messages

*Session Messages* are a subset of all *Messages* and therefore conformant with the interface description specified in 2.2 of this document. Additional attributes for the four *Session Message* types are hereinafter specified.

#### 3.3.1. Session Request

The *Message* must contain the following elements in its `header` object:

| Level 2 | Level 3            | Name      | Type         | Description        |
| ------- | ------------------ | --------- | ------------ | ------------------ |
| Header  |                    |           |              |                    |
|         | Session identifier | `session` | Hex(128-bit) | Randomly set       |
|         | Message type       | `type`    | String       | Fixed value: `100` |

#### 3.3.2. Session Reply

The *Message* must contain the following elements in its `header` and `body` objects:

| Level 2 | Level 3            | Name      | Type         | Description                         |
| ------- | ------------------ | --------- | ------------ | ----------------------------------- |
| Header  |                    |           |              |                                     |
|         | Session identifier | `session` | Hex(128-bit) | Value received in `Session Request` |
|         | Message type       | `type`    | String       | Fixed value: `200`                  |
| Body    |                    |           |              |                                     |
|         | Return code        | `return`  | String       | See 3.3.2.1                         |

##### 3.3.2.1. Possible Return Codes

| Return Code | Meaning                                           |
| :---------- | :------------------------------------------------ |
| `1`         | Session accepted                                  |
| `2`         | Session declined; Session Request not valid       |
| `3`         | Session declined; Initiator declined              |
| `4`         | Session declined; temporary disruption of service |

#### 3.3.3. Termination

The *Message* must contain the following elements in its `header` object:

| Level 2 | Level 3            | Name      | Type         | Description                         |
| ------- | ------------------ | --------- | ------------ | ----------------------------------- |
| Header  |                    |           |              |                                     |
|         | Session identifier | `session` | Hex(128-bit) | Value received in `Session Request` |
|         | Message type       | `type`    | String       | Fixed value: `300`                  |

#### 3.3.4. Session Abort

The *Message* must contain the following elements in its `header` and `body` objects:

| Level 2 | Level 3            | Name      | Type         | Description                         |
| ------- | ------------------ | --------- | ------------ | ----------------------------------- |
| Header  |                    |           |              |                                     |
|         | Session identifier | `session` | Hex(128-bit) | Value received in `Session Request` |
|         | Message type       | `type`    | String       | Fixed value: `400`                  |
| Body    |                    |           |              |                                     |
|         | Cause code         | `cause`   | String       | See 3.3.4.1                         |

##### 3.3.4.1. Possible Cause Codes

| Cause Code | Meaning                           |
| :--------- | :-------------------------------- |
| `1`        | Message acknowledgement timeout   |
| `2`        | Session timeout                   |
| `3`        | Wrong or invalid message received |
| `4`        | Temporary disruption of service   |
| `5`        | Unspecified                       |

## 4. Application Layer

### 4.1. Definitions

**Application**</br>
Structured interaction between VASPs for a dedicated purpose, e.g. agreeing on a virtual asset transfer and transmitting the related travel rule information. Defined by a set of *Application Massages*.

**Application Message**</br>
*Message* with a defined set of elements to support the flow of *Messages* needed for an *Application*.

### 4.2. Specification Rules for Application Messages

#### 4.2.1. Conformance with Message Interface

Each `Application Message` must be conformant with the interface description for all *Messages* as specified in 2.2 of this document.

#### 4.2.2. Unique Message Type

Each *Application Message* type must specify a unique message type to be set as value assigned to the `type` element of the *Message's* `header` object.

#### 4.2.3. Specific Elements in `body` Object

Specific elements of an *Application Message* must be part of the *Message's* `body` object.

#### 4.2.4. Part of a Session

*Application Messages* must only be sent as part of a *Session* in state `open`. The value assigned to the `session` element of the `header` object must be the value received in the `Session Request` *Message* that initiated the *Session*.

#### 4.2.5. Initiator Sends First Application Message

The first *Application Message* within a *Session* must be sent by the *Initiator*.

#### 4.2.6. First Application Message Defines the Flow

The first *Application Message* sent within a *Session* defines the *Application* and the flow of subsequent *Application Messages*.

# Motivation

**Edge Cases** -- The protocol flow in the OpenVASP White Paper did not consider failure situations arising from unrealiable communication.

**Incomplete session state model** -- No formal state model was specified for OpenVASP sessions, resulting in interoperability issues between different implementations. 

**Better Abstraction from transport layer** -- In line with the ambition to allow for protocol implementation on top of different messaging systems, this OVIP better abstracts the specification of OpenVASP messages from actual implementations (e.g. Whisper).

# Rationale

**Three-layer model** -- Text.

**Joint message interface** -- Text.

**Session state model** -- Text.

**Ability to abort sessions** -- Text.

# Backwards Compatibility

The specification proposed in this OVIP is not backwards compatible.

